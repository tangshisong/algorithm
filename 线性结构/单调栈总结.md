# 用法
单调递减/增栈：每次遇到比栈顶大/小的元素就要进行出栈操作，一般是为了寻求某个元素右边第一个比他大/小的元素。     
以单调递增栈为例：   
* 规则：如果新的元素比栈顶元素大，就入栈；如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小。   
* 效果：栈内元素一直保持单调递增；当元素出栈时，说明新元素是出栈元素向后找第一个比其小的元素；当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素
# [每日温度](https://leetcode-cn.com/problems/daily-temperatures/)
题意：为每个元素寻找右边第一个比他大的元素    
很显然需要维护一个单调递减栈
```cpp
    vector<int> dailyTemperatures(vector<int>& T) {
        int n = T.size();
        vector<int> ans(n,0);
        stack<int> s;
        s.push(0); 
        int i = 1;
        while(i < n)
        {
            while(!s.empty()&&T[s.top()] < T[i])//出现一个非递减元素
            {
                ans[s.top()] = i - s.top();
                s.pop();
            }
//栈为空或者是递减序列
            s.push(i);
            ++i;

        }

        return ans;
    }
```

# [直方图最大矩阵](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
对于每一个柱，需要找到其左右第一个比他小的数，维护一个单调递增栈
```cpp
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);//为了让最后的柱形被计算出来
        stack<int>  s;
        s.push(-1);
        int ans = 0;
        int i = 0;
        int size = heights.size();

        while(i < size)
        {
            
            while(s.top() != -1 && heights[s.top()] > heights[i])
            {
                int t = s.top();
                s.pop();
                ans = max(ans,heights[t]*(i-s.top()-1));
            }
            s.push(i);
            ++i;
        }
        return ans;
    }
```


# [最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
同样使用单调栈，借用最大直方图的代码，每行每行的算就行了
```cpp
    int largestRectangleArea(vector<int>& height)
    {
        stack<int> s;
        s.push(-1);
        //height.push_back(-1);
        int ans = 0;
        for(int i = 0;i < height.size();++i)
        {
            while(s.top() != -1 && height[s.top()] > height[i])
            {
                int t = s.top();
                s.pop();
                ans = max(ans,height[t]*(i-s.top()-1));
            }
            s.push(i);
        }
        return ans;
    }
    int maximalRectangle(vector<vector<char>>& matrix) {
        int n = matrix.size();
        if(n == 0)
        return 0;
        int m = matrix[0].size();
        vector<int> height(m,0);
        height.push_back(-1);
        int ans = 0;
        for(int i = 0;i < n;++i)
        {
            for(int j = 0;j < m;++j)
            if(matrix[i][j] == '0')
            height[j] = 0;
            else
            height[j] = height[j] + (matrix[i][j]-'0');
            int temp = largestRectangleArea(height);
            ans = max(ans,temp);
        }
        return ans;
    }
```
