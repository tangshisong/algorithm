# [单调栈](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
暴力解法：对于每一个柱子，我们需要向左向右找到最后一个大于等于它的柱子高度，然后每一个进行比较。   
时间复杂度为O(N^2)   
单调栈：   
在一个一维数组中，帮助我们找到某个元素的左侧或右侧第一个大于或小于该元素的数。 
```cpp
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);
        //加入哨兵值，便于原先heights中的最后位置的值弹出
        //因为需要比最后一个值小的值，才能把最后一个值卡在
        //中间计算面积
        stack<int>  stacks;
        stacks.push(-1);
        //栈压入哨兵值，便于heights打头的数组进行操作
        //压入-1为方便计算打头位置的面积
        int   maxs = 0;
        for(int  i=0;i<heights.size();i++)
        {
            while(stacks.top() != -1&&heights[stacks.top()] > heights[i])
            //栈里面后面比前面大的时候才压入，相当于顺序压入，当
            //当前值比栈顶的值小的时候，相当于两个比栈顶小的值把
            //栈顶位置的数卡在中间，比如5，6，2，栈顶数为6
            //此时可以计算栈顶6围成的矩形面积
            {
                int  nums = stacks.top();
                stacks.pop();
                maxs = max(maxs,heights[nums]*(i-stacks.top()-1));
                //面积计算公式为当前下标值*(左右两边的坐标减去1)
            }
            stacks.push(i);
            //栈前面都为比当前值小的时候，无法将栈顶值卡在中间了
            //此时压入当前坐标
        }
        return  maxs;
    }
```
