# [最小的最大值](https://leetcode-cn.com/problems/trapping-rain-water/)
思路分析：对于每一个点，我们只需要找到其左边的最大值和右边的最大值，然后根据木桶效应选取最小值作为上界。那么该点所能装的水量为`min(max)-height[i]`    
时间复杂度：O(N^2)   空间复杂度：O(1)
```cpp
	int trap(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        for(int i = 0;i < n;++i)
        {
            int left_max = 0,right_max = 0;
            for(int k = 0;k <= i;++k) //找当前点的左边最大值
            left_max = max(left_max,height[k]);
            for(int k = i;k < n;++k) //当前点的右边最大值
            right_max = max(right_max,height[k]);
            //选最大值中最小
            ans += (max(0,min(left_max,right_max)-height[i]));
        }
        return ans;
    }
```
优化：可以通过预处理寻找每一个点的左右最值。    
时间复杂度：O(N)  空间复杂度：O(N)
```cpp
	int trap(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        vector<int> left(n,0);
        vector<int> right(n,0);
        for(int i = 1;i < n;++i)
        left[i] = max(left[i-1],height[i-1]);
        for(int i = n-2;i >= 0;--i)
        right[i] = max(right[i+1],height[i+1]);
        for(int i = 1;i < n-1;++i)
        ans += (max(0,min(left[i],right[i])-height[i]));
        return ans;
    }
```
