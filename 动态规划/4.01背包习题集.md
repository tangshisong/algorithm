[hdu 2546](http://acm.hdu.edu.cn/showproblem.php?pid=2546)<br>
分析：就是说当余额W>=5时可以买任何一样菜，否则不能买。思路就是我们把最贵的一样菜留在最后买，这样只考虑除了最贵的菜的其他菜就是一个简单的01背包。
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
	int N,W,ans;//菜的种类、卡余额、最小值 
	while(scanf("%d",&N)&&N)
	{
		int* price = new int[N];
		for(int i = 0;i < N;i++)
		scanf("%d",&price[i]);//价值和质量都是price[]
		scanf("%d",&W);
		vector<int> dp(W+1,0);
		
		if(W < 5)//不能继续购买了
		{
			printf("%d\n",W);
			continue;
		}
		
		sort(price,price+N);
		
		for(int i = 0;i < N-1;i++)//把最贵的菜除去，留在最后买
		for(int j = W-5;j >= price[i];j--)//至少留5块钱，找到购买价格最高的
		dp[j] = max(dp[j],dp[j-price[i]]+price[i]);
		
		ans = W-dp[W-5]-price[N-1];
		
		printf("%d\n",ans);
	}
}
```
[hdu 2955](http://acm.hdu.edu.cn/showproblem.php?pid=2955)<br>
分析：emmmm我一直没有读懂题目想干什么，
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
	int T,N;
	double P;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lf%d",&P,&N);
		int* v = new int[N];
		double* p = new double[N];
		
		int W = 0;
		for(int i = 0;i < N;i++)
		{
			scanf("%d%lf",&v[i],&p[i]);
			W += v[i];
		}
		
		vector<double> dp(W+1,0);
		dp[0] = 1;
		
		for(int i = 0;i < N;i++)
		for(int j = W;j >= v[i];j--)
		dp[j] = max(dp[j],dp[j-v[i]]*(1-p[i]));
		
		for(int i = W;i >= 0;i--)
		{
			if(dp[i] > (1-P))
			{
				printf("%d\n",i);
				break;
			}
		}
	}
}
```

[poj 2184](http://poj.org/problem?id=2184)<br>
分析：<br>
题目大意是：有N头牛，每头牛都有S和F两种属性值，现在要选取一群牛，记它们的S（smartness）和F（funness）的总和分别是TS和TF，如何选取这群牛，使得TS+TF的总和最大且TS和TF均为非负数。<br>
这道题，技巧真的蛮多的，特别是在处理负数这里，采用了坐标偏移，真的很巧妙，我也是刚开始学dp，看了题解说把S当作质量，F当作价值，然后用01背包，想了很久还是没有想明白。<br>
首先，我们将S看作背包的质量，F当作物品的价值，那么dp[j]表示：前i头牛的S总和为j时，F的最大值，而题目要求我们求TS+TF的最大值，实际上这就等价于dp[j]+j的最大值。我们将状态以及各类变量定义好了。
另外，我们还得考虑dp这个数组的大小以及取值，题目说了限制条件：牛的个数区间为1~100，S和F的取值在-1000~1000，所以S的取值在-100\*1000~100\*1000，那我们dp数组需要的大小MAX = 2\*100\*1000，


