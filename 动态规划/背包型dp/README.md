### 基本描述
定义背包最大承受质量：W，物品件数：N，对于每件物品i其质量：w[i]，价值：v[i]，如何装入物品使得背包总价值最大。<br>
背包模型是dp问题中很重要的一个模型，很多问题都是由其衍生而来，不同的背包有不同的限制。

### 01背包（每种物品只能选一个或不选）

首先想到的就是定义数组dp[N][W]来记录不同装载量的背包对于不同物品的选择情况。故dp[i][j]表示：对前i件物品且背包承受质量为j时背包最大价值。<br>
在01背包中，对于每个物品我们仅仅考虑其要不要装入（这是我们的入手点），假设当前背包的质量为j，对于该背包我们已经考虑完了前i-1件物品的装入情况，并且其最大价值记录在dp[i-1][j]中，现在我们的关键点是：第i件物品能否装入？ 最简单的情况当然是不装入，直接继承dp[i-1][j]的值，因为我们在这里对背包什么也没有做啊，所以其最大价值就等于同等质量且只考虑前i-1件物品的背包。另一种情况当然是装入，装入之前还得考虑能不能装下，即要满足j-w[i]>=0，满足这个门槛之后，来考虑装入的价值；首先物品i要装入，背包j需要留出w[i]的位置才行啊，所以我们就找到dp[i-1][j-w[i]]这个背包，刚好能装入第i件物品。最后到底要不要装入，就看装入前后谁的价值高，即得出状态转移方程：

`dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + v[i])` <br>

很明显这是两层循环，时间复杂度和空间复杂度为：O（NW）；但是通过分析我们可以进一步降低空间复杂度，这种方法称为滚动数组<br>
仔细观测状态转移方程，你会发现：我们每次在计算dp[i][j]的时候，只看了dp[i-1][]的这一行，就是说无论当前背包的质量j是多少，我们都是在第i-1件物品的各个状态基础上计算第i件物品的最大价值，二维数组实际上记录了很多历史信息，但不是我们一直需要的。所以我们只需要一行就够了，即dp[W]够用了，但是还要注意一点是枚举顺序（即for循环的遍历顺序），必须是逆序枚举！就是说我们得从后往前推dp[j]的值，你想嘛，上面的状态方程我们都是根据质量小的背包j-w[i]推出质量大的背包j的最大价值，如果顺序枚举的话，从小推大，根本不可能嘛。<br>

```cpp
for(int i = 1;i <= N;i++)
for(int j = W;j >= w[i];j--)
dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
```
这里还有一个问题，如果我把条件改为：当背包装满时其最大价值为多少？<br>
这就是**01装满背包，和01背包的不同仅仅在于初始化** 首先，我们把dp[N][M]初始化为负无穷，表示一个非法值，把dp[][0]初始化为0，表示我们用质量为0的物品刚好装满了容量为0的背包。当dp[i-1][j]或者dp[i-1][j-v[i]]为负数的时候，就表示上一层的j或者j-c[i]容量时装不满，那么此时装c[i]也肯定是不满的状态。当它们不为负数时，那么我们再装c[i]时得到的也是恰好装满的。最后扫描一下最后一层的所有状态，最大值即为满背包解。对于滚动数组也一样，把dp[0]初始化为0即可。<br>

### 完全背包（每件物品有无穷件）

相比01背包，完全背包的每件物品有无穷件，我们在这所采用的状态和01背包一致。<br>
在01背包的基础上，我们也只考虑两种情况，物品i要不要装。
* 不装，这里和01背包一样，不装就继承上一个状态，即dp[i-1][j]
* 装入，首先当然得满足j-w[i]>=0，即能够装入，但是我们得考虑一个问题，因为完全背包有无数件可以装，所以我们在装完第i件物品之后，还得考虑要不要继续装，所以他应该跳转到dp[i][j-w[i]]上，而不是dp[i-1][j-w[i]]，这里是和01背包不同的点。
状态转移方程：`dp[i][j] = max(dp[i-1][j],dp[i][j-w[i]] + v[i])`<br>
和01背包一样，完全背包也能采用滚动数组：`dp[j] = max(dp[j],dp[j-w[i]] + v[i])`。你会发现，完全背包难道和01背包完全一样？当然不是，他们的区别在于枚举顺序的不同，**01背包要求逆序枚举，完全背包要求正序枚举！**为什么呢？我们看完全背包的状态转移方程，发现：在计算dp[i][j]的时候，我们只用到了其上方的值dp[i-1][j]和其左边的值dp[i][]，如果从小向大推，他左边的值dp[i][]总是已经计算出结果来了，而计算出dp[i][j]之后，其上方的dp[i-1][j]当然用不到了，所以可以覆盖了。

```cpp
for(int i = 1;i <= N;i++)
for(int j = w[i];j <= W;j++)
dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
```

### 多重背包（每件物品有num[i]件可选）
我们可以把它转换成01背包，也就是说每类物品有num[i]个可选，那我们可以把它当成相同价值的num[i]个物品的01背包。
```cpp
for(int i = 1;i <= N;i++)
for(int k = 1;k <= num[i];k++)
for(int j = W;j >= w[i];j--)
dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
```
这样的时间复杂度为O（W*sum(num[i])），我们可以用二进制的思想把复杂度降到O（W*sum（log num[i]））<br>
上面的方法中，我们把每类物品i分成num[i]个，然后代入01背包；二进制的方法中，我们把每类物品分为log num[i]堆（向上取整），每堆都有一个系数。比如，13 = 1 + 2 + 4 + 6，我们将13分成了4堆，这四个数就是每堆物品的系数number。
```cpp
for(int i = 1;i <= N;i++)//遍历每种物品 
{
	//如果第i类物品的质量总和已经超过了背包的容纳量，则相对背包来说该类物品无穷件，使用完全背包
	if(num[i]*w[i] > W) 
	complete(w[i],v[i]);//滚动数组顺序枚举
	else//否则用01背包
	{
		int k = 1,number=num[i];
		while(k <= number)
		{
			zero(k*w[i],k*v[i]);//滚动数组逆序枚举
			number -= k;
			k<<=1;//k*=2
		}
		zero(number*w[i],number*v[i]);//剩下的那个系数，在上面即6
	}
}
```

### 实战
01背包<br>
[hdu 2602 Bone Collector](http://acm.hdu.edu.cn/showproblem.php?pid=2602)
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
using namespace std;
int main()
{
	int T,N,W;
	scanf("%d",&T);
	while(T)
	{
		T--;
		scanf("%d %d",&N,&W);
		int* v = new int[N];
		for(int i = 0;i < N;i++)
		scanf("%d",&v[i]);
		int* w = new int[N];
		for(int i = 0;i < N;i++)
		scanf("%d",&w[i]);
		
		vector<int> dp(W+1,0);
		for(int i = 0;i < N;i++)
		for(int j = W;j >=w[i];j--)
		dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
		printf("%d\n",dp[W]);
		delete [] v;
		delete [] w;
	}
}
```







