## [字符串划分方案](https://leetcode-cn.com/problems/decode-ways/)  
题意：1-26对应A-Z，问给定数字串能够解码成多少种字符串。  
定状态：  
最后一步：根据编码方法，我们可知一个字符可以对应一位或两位数字。所以最后只需要看一位（S[i]）和两位数字（S[i-1]和S[i]）构成的字符。  
原问题：有多少种方案可以将数字串S[0...n]解码成字符串。    
子问题：有多少种方案可以将数字串S[0...n-1]或S[0...n-2]解码成字符串。    
dp[i]代表数字串S[0...i]有多少种解码方案。   
求方程：  
dp[i] = dp[i-1] + dp[i-2]  
判边界：
dp[0] = 1 / 0 根据S[0]判断    
dp[1] 根据情况判断
```cpp
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n,0);
        //n == 1的边界条件
        if(int(s[0]-'0'))
        dp[0] = 1;
        else
        dp[0] = 0;

        //n == 2的边界条件
        if(n >= 2)
        {
            int t = s[1] - '0';
            if(t >= 1 && t <= 9)
            dp[1] += dp[0];

            t = (s[0]-'0')*10 + s[1] - '0';
            if(t >= 10 && t <= 26)
            dp[1] ++;
        }

        for(int i = 2;i < n;++i)
        {
            //一个字符
            int t = s[i] - '0';
            if(t >= 1&& t <= 9)
            dp[i] += dp[i-1];

            if(i >= 2)
            {
                //两个字符
                t = (s[i-1]-'0')*10 + s[i] - '0';
                if(t >= 10 && t <= 26)
                dp[i] += dp[i-2];
            }
        }
        return dp[n-1];
    }
```


