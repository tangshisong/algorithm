# [最长连续单调子序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)
这个很简单，和最长连续子序列和差不多，定义状态dp[i]：以nums[i]结尾的最长连续单调递增子序列长度。<br>
状态转移方程：`dp[i] = max(dp[i-1]+1,dp[i])`
```cpp
    int findLengthOfLCIS(vector<int>& nums) {
        int size = nums.size();
        if(size == 0)
            return 0;
        int* dp = new int[size];
        int ans = 1;
        for(int i = 0;i < size;i++)//每一个元素本身为一个序列
            dp[i] = 1;
        
        for(int i = 1;i < size;i++)
        {
            if(nums[i] > nums[i-1])
                dp[i] = max(dp[i-1]+1,dp[i]);
            ans = max(ans,dp[i]);
        }
        return ans;
    }
```
# [最长单调子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
注意：这个不要求连续!是单调绝对递增<br>
我们很容易定义出状态dp[i]表示以num[i]结尾的序列中最长单调子序列长度。<br>

状态转移方程：dp[i] = max(dp[j] + 1,dp[i]) （num[j]<num[i]）

```cpp
    int lengthOfLIS(vector<int>& nums) {
        int size = nums.size();
        if(size <= 0)
            return 0;
        int* dp = new int[size];
        for(int i = 0;i <size;i++)
            dp[i] = 1;
        int ans = -1;
        for(int i = 0;i < size;i++)
        {
            for(int j = 0;j < i;j++)
            if(nums[i] > nums[j])
            dp[i] = max(dp[j]+1,dp[i]);
            
            ans = max(ans,dp[i]);
        }

        return ans;
    }
```
