在此列举几个经典的线性模型，最好记住其状态转移方程！！所有代码均能AC<br>
一般来说子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串（即除特殊说明外，子序列不要求连续）。
## 最长连续子序列和
题目要求我们在一个数组里找到一个最大连续的子数组和，这是一个简单的线性dp。我们只需要从第一个元素开始扫描，然后依次往后走，如果加上了当前元素总和反而小了，说明在这里我们找到了一个连续子数组（不一定是最大的），然后记录下来，以当前位置为起点继续往后走找新的连续子数组。最后在备忘录中比较一下即可。

定义状态：dp[i]表示以nums[i]结尾的最大连续子数组和

状态转移方程：`dp[i] = max(nums[i],dp[i-1] + nums[i])`

时间复杂度：O（N）   空间复杂度：O（N）

```cpp
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        int* dp = new int[len];
        dp[0] = nums[0];
        int max = nums[0];
        for(int i = 1;i < len;i++)
        {
            if(nums[i] > dp[i-1]+nums[i])
                dp[i] = nums[i];
            else
                dp[i] = dp[i-1]+nums[i];
            if(dp[i] > max)
                max = dp[i];
        }
        return max;
    }
```
实际上我们可以优化一下空间复杂度到O（1），注意到程序在每次比较的时候，我们都只是用到了前面最大的一次结果，故备忘录不需要将每次的结果记录下来。
```cpp
    int maxSubArray(vector<int>& nums) {
        int len = nums.size(),sum = 0,ans = INT_MIN;
        for(int i = 0;i < len;i++)
        {
            sum = max(sum+nums[i],nums[i]);
            ans = max(sum,ans);
        }
        return ans;
    }
```
## [最长连续子序列积](https://leetcode-cn.com/problems/maximum-product-subarray/)
这道题就是把上一道变了一下，即求和变成求积了，所以我们的状态转移方程也差不多：`dp[i] = max(dp[i-1]*nums[i],nums[i])`<br>
但是这样是不行的，因为积里面的负数会对结果产生很大的影响，即让最小变最大，最大变最小。<br>
所以，在这里我们需要维护两个dp数组，一个用于保存最大值，一个用于保存最小值，当我们遇到一个负数的时候，我们将最大值和最小值交换（因为负号会让他们地位交换），所以另一个状态转移方程：`dp1 = min(dp1[i-1]*nums[i],nums[i])`<br>
我们可以根据最长连续子序列和中的优化，将空间复杂度优化到O(1)，即我们只需要维护一个最大值和最小值即可。<br>
```cpp
    int maxProduct(vector<int>& nums) {
        int maxi,mini,ans;
        maxi = mini = ans = nums[0];
        for(int i = 1;i < nums.size();i++)
        {
            if(nums[i] < 0)
            {
                maxi ^= mini;
                mini ^= maxi;
                maxi ^= mini;
            }
            maxi = max(maxi*nums[i],nums[i]);
            mini = min(mini*nums[i],nums[i]);
            ans = max(maxi,ans);
        }
        return ans;
    }
```



## [最长单调子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
注意：这个不要求连续!是单调绝对递增<br>
我们很容易定义出状态dp[i]表示以num[i]结尾的序列中最长单调子序列长度。<br>

状态转移方程：dp[i] = max(dp[j] + 1,dp[i]) （num[j]<num[i]）

```cpp
    int lengthOfLIS(vector<int>& nums) {
        int size = nums.size();
        if(size <= 0)
            return 0;
        int* dp = new int[size];
        for(int i = 0;i <size;i++)
            dp[i] = 1;
        int ans = -1;
        for(int i = 0;i < size;i++)
        {
            for(int j = 0;j < i;j++)
            if(nums[i] > nums[j])
            dp[i] = max(dp[j]+1,dp[i]);
            
            ans = max(ans,dp[i]);
        }

        return ans;
    }
```

## [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
定义状态dp[i][j]：以字符串A[i]和字符串B[j]结尾的两个子串的最长公共子序列长度<br>

同样考虑两种情况：
* 先看边界，这里只有当某个字符串为空时dp为0即dp[i][0] = dp[0][j] = 0;
* 当A[i] == B[j]时，dp[i][j] = dp[i-1][j-1] + 1  （如果我两相等，其长度当然是在前两个身上加呗）
* 当A[i] != B[j]时，dp[i][j] = max(dp[i-1][j],dp[i][j-1]) （如果我两不等，就判断有你没我和有我没你的两种情况谁更大呗）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#define MAX 1001
using namespace std;
int dp[MAX][MAX];
int main()
{
	string s1,s2;
	cin>>s1>>s2;
	s1 = "#" + s1;
	s2 = "#" + s2;//为了方便使用，#作为占位符 
	int l1 = s1.size();
	int l2 = s2.size();
	if(l1==1 || l2==1)
	{
		printf("0\n");
		return 0;
	}
	memset(dp,0,sizeof(dp));
	
	for(int i = 1;i < l1;i++)
	for(int j = 1;j < l2;j++)
	if(s1[i] == s2[j])
	dp[i][j] = dp[i-1][j-1] + 1;
	else
	dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
	printf("%d\n",dp[l1-1][l2-1]);
}
```

## 最长公共单调子序列

