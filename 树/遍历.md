![](https://github.com/tangshisong/algorithm/blob/master/pic/3.png)
## 二叉树的先序、中序、后序、层次遍历
先序和中序都是“一路向左，走完走右”，不同点在于先序遍历是在入栈的时候访问，中序遍历是在出栈的时候访问
```cpp
struct node{
	int val;
	node* left = NULL;
	node* right = NULL;
};
void pre(node* t)
{
	stack<node*> s;
	while(t || !s.empty())
	{
		while(t) //一路向左 
		{
			cout<<t->val;
			s.push(t);
			t = t->left;
		}
		if(!s.empty()) //左边走完了走右 
		{
			node* temp = s.top();
			s.pop();
			t = t->right;
		}
	}
}
```
```cpp
void in(node* t)
{
	stack<node*> s;
	while(t || !s.empty())
	{
		while(t) //一路向左 
		{
			s.push(t);
			t = t->left;
		}
		if(!s.empty()) //左边走完了走右 
		{
			node* temp = s.top();
			cout<<temp->val; //中序访问时间是出栈时 
			s.pop();
			t = t->right;
		}
	}
}
```
层次遍历
```cpp
void level(node* t)
{
	queue<node*> q;
	q.push(t);
	while(!q.empty())
	{
		t = q.front();
		cout<<t->val;
		q.pop();
		if(t->left)  //左儿子入队 
		q.push(t->left);
		if(t->right)  //右儿子入队 
		q.push(t->right);
	}
}
```
## 遍历序的互相转换
![](https://github.com/tangshisong/algorithm/blob/master/pic/4.png)
两种方法：（1）先建树后遍历，此方法时间空间开销大 （2）根据序的特点进行划分
```cpp
int pre[] = {1,2,3,4,5,6,7,8,9};
int post[] = {3,2,5,8,7,9,6,4,1};
int in[] =   {2,3,1,5,4,7,8,6,9};
void postorder(int preL,int preR,int inL,int inR)//求后序
{
	//递归边界 
	if(preL > preR)
	return;
	
	//找根 
	int t;
	for(t = inL;t <= inR;++t)
	if(in[t] == pre[preL])
	break;
	
	//子树划分 
	postorder(preL + 1,preL + t - inL ,inL,t-1); //t-inL为左子树的长度 
	postorder(preL + t - inL + 1,preR,t+1,inR);
	
	//访问 
	printf("%d ", pre[preL]);
}
void preorder(int postL,int postR,int inL,int inR)//求先序
{
	//递归边界
	if(postL > postR)
	return ;
	//找根
	int t;
	for(t = inL;t <= inR;++t)
	if(post[postR] == in[t])
	break;
	//访问
	printf("%d ", post[postR]);
	//子树划分
	preorder(postL,postL + t - inL - 1,inL,t-1);
	preorder(postL + t - inL,postR-1,t+1,inR);
}
```
## 根据遍历序建树
稍微修改上面的代码即可
```cpp
node* create(int preL,int preR,int inL,int inR)
{
	if(preL > preR)
	return NULL;
	int t;
	for(t = inL;t <= inR;++t)
	if(pre[preL] == in[t])
	break;
	node* root = new node(pre[preL]);
	root->left = create(preL+1,preL+t-inL,inL,t-1);
	root->right = create(preL+t-inL+1,preR,t+1,inR);
	return root;
}
```

