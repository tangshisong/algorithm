## [二叉树高度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)
两种方法：（1）递归（2）分层的层次遍历  
```cpp
    int maxDepth(TreeNode* root) {
        if(root)
        {
            int left = maxDepth(root->left);
            int right = maxDepth(root->right);
            return 1+(left > right ? left : right);
        }
        return 0;
    }
```
## [N叉树高度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)
```cpp
//也可以使用N叉树的分层层次遍历
    int maxDepth(Node* root) {
        if(root)
        {
            int max = 0;
            for(int i = 0;i < root->children.size();++i)
            {
                int k = maxDepth(root->children[i]);
                if(k > max)
                max = k;
            }
            return 1+max;
        }
        return 0;
    }
```
## [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
根据题目的意思，只需要对二叉树的每一个结点求左右子树的高度和，然后选出最大的那个就是直径.
## [二叉树的最小高度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/)
定义高度：根到叶节点的高度，所以不能简单的把二叉树的高度改为求最小值
```cpp
    int minDepth(TreeNode* root) {
        if(root)
        {
            int l = minDepth(root->left);
            int r = minDepth(root->right);
            return l&&r ? 1+(l>r?r:l) : 1+l+r;
        }
        return 0;
    }
```
